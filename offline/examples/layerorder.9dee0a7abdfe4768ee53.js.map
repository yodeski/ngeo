{"version":3,"sources":["webpack:///./examples/layerorder.js","webpack:///./src/misc/sortableComponent.js","webpack:///./src/misc/syncArrays.js","webpack:///./src/source/AsitVD.js"],"names":["__webpack_require__","exports","module","angular","ngeoBase","name","ngeoMapModule","ngeoMiscSortableComponent","MainController","$scope","asitvd","olLayerTile","source","ngeoSourceAsitVD","layer","set","boundaries","olSourceTileWMS","url","params","LAYERS","serverType","waterBodies","cities","this","map","olMap","layers","view","olView","projection","resolutions","center","zoom","roads_","selectedLayers","_syncArrays2","default","getLayers","getArray","$watchCollection","render","prototype","toggleRoadsLayer","val","undefined","indexOf","addLayer","removeLayer","controller","_index","requires","push","component_","$timeout","restrict","link","scope","element","attrs","sortable","$eval","goog","asserts","assert","Array","isArray","length","resetUpDragDrop","options","ret","handleClassName","getOptions","callbackFn","callbackCtx","children","i","data","sortableElement","$","sortableOptions","axis","classes","ui-sortable-helper","on","event","ui","oldIndex","item","newIndex","index","$apply","splice","Function","apply","directive","arr1","arr2","reverse","filter","dereg1","ii","j","dereg2","googAsserts","asitVDResolutions","asitVDTileGrid","olTilegridWMTS","extent","matrixIds","value","_classCallCheck","_possibleConstructorReturn","__proto__","Object","getPrototypeOf","call","attributions","requestEncoding","style","matrixSet","format","tileGrid","_inherits","olSourceWMTS"],"mappings":"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","file":"layerorder.9dee0a7abdfe4768ee53.js","sourcesContent":["/**\n * @module app.layerorder\n*/\nconst exports = {};\n\nimport './layerorder.css';\nimport './common_dependencies.js';\nimport ngeoBase from 'ngeo/index.js';\n\nimport ngeoMapModule from 'ngeo/map/module.js';\n\n/** @suppress {extraRequire} */\nimport ngeoMiscSortableComponent from 'ngeo/misc/sortableComponent.js';\n\nimport ngeoMiscSyncArrays from 'ngeo/misc/syncArrays.js';\nimport ngeoSourceAsitVD from 'ngeo/source/AsitVD.js';\n\n/** @suppress {extraRequire} */\nimport ngeoProjEPSG21781 from 'ngeo/proj/EPSG21781.js';\n\nimport olMap from 'ol/Map.js';\nimport olView from 'ol/View.js';\nimport olLayerTile from 'ol/layer/Tile.js';\nimport olSourceTileWMS from 'ol/source/TileWMS.js';\n\n\n/** @type {!angular.Module} **/\nexports.module = angular.module('app', [\n  ngeoBase.module.name,\n  ngeoMapModule.name,\n  ngeoMiscSortableComponent.name,\n]);\n\n\n/**\n * @param {angular.Scope} $scope Scope.\n * @constructor\n * @export\n * @ngInject\n */\nexports.MainController = function($scope) {\n\n  /** @type {ol.layer.Tile} */\n  const asitvd = new olLayerTile({\n    source: new ngeoSourceAsitVD({\n      layer: 'asitvd.fond_couleur'\n    })\n  });\n  asitvd.set('name', 'asitvd');\n\n  /** @type {ol.layer.Tile} */\n  const boundaries = new olLayerTile({\n    source: new olSourceTileWMS({\n      url: 'https://wms.geo.admin.ch',\n      params: {'LAYERS': 'ch.swisstopo.swissboundaries3d-gemeinde-flaeche.fill'},\n      serverType: 'mapserver'\n    })\n  });\n  boundaries.set('name', 'Boundaries');\n\n  /** @type {ol.layer.Tile} */\n  const waterBodies = new olLayerTile({\n    source: new olSourceTileWMS({\n      url: 'https://wms.geo.admin.ch',\n      params: {'LAYERS': 'ch.swisstopo.geologie-gravimetrischer_atlas'},\n      serverType: 'mapserver'\n    })\n  });\n  waterBodies.set('name', 'Water bodies');\n\n  /** @type {ol.layer.Tile} */\n  const cities = new olLayerTile({\n    source: new olSourceTileWMS({\n      url: 'https://wms.geo.admin.ch',\n      params: {'LAYERS': 'ch.swisstopo.dreiecksvermaschung'},\n      serverType: 'mapserver'\n    })\n  });\n  cities.set('name', 'Cities');\n\n  /**\n   * @type {ol.Map}\n   * @export\n   */\n  this.map = new olMap({\n    layers: [\n      asitvd,\n      boundaries,\n      waterBodies,\n      cities\n    ],\n    view: new olView({\n      projection: 'EPSG:21781',\n      resolutions: [1000, 500, 200, 100, 50, 20, 10, 5, 2.5, 2, 1, 0.5],\n      center: [600000, 200000],\n      zoom: 1\n    })\n  });\n\n  const map = this.map;\n\n  /**\n   * @type {ol.layer.Tile}\n   * @private\n   */\n  this.roads_ = new olLayerTile({\n    source: new olSourceTileWMS({\n      url: 'https://wms.geo.admin.ch',\n      params: {'LAYERS': 'ch.bafu.laerm-strassenlaerm_tag'},\n      serverType: 'mapserver'\n    })\n  });\n  this.roads_.set('name', 'Roads');\n\n  /**\n   * @type {Array.<ol.layer.Base>}\n   * @const\n   * @export\n   */\n  this.selectedLayers = [];\n\n  const selectedLayers = this.selectedLayers;\n\n  ngeoMiscSyncArrays(map.getLayers().getArray(), selectedLayers, true, $scope,\n    layerFilter);\n\n  // watch any change on layers array to refresh the map\n  $scope.$watchCollection(() => selectedLayers, () => {\n    map.render();\n  });\n\n  /**\n   * @param {ol.layer.Base} layer Layer.\n   * @return {boolean} `false` if the layer shouldn't be part of the selected\n   *     layers.\n   */\n  function layerFilter(layer) {\n    return layer !== asitvd;\n  }\n\n};\n\n\n/**\n * Add/remove the \"Roads\" layer when used as a setter, and return whether\n * the \"Roads\" layer is in the map when used as a getter.\n * @param {boolean|undefined} val Value.\n * @return {boolean|undefined} `true` if the \"Roads\" layer is in the map,\n *     `false` if the \"Roads\" layer is not in the map, `undefined` if the\n *     function is used as setter.\n * @export\n */\nexports.MainController.prototype.toggleRoadsLayer = function(val) {\n  if (val === undefined) {\n    return this.map.getLayers().getArray().indexOf(this.roads_) >= 0;\n  } else {\n    if (val) {\n      this.map.addLayer(this.roads_);\n    } else {\n      this.map.removeLayer(this.roads_);\n    }\n  }\n};\n\n\nexports.module.controller('MainController', exports.MainController);\n\n\nexport default exports;\n\n\n\n// WEBPACK FOOTER //\n// ./examples/layerorder.js","/**\n * @module ngeo.misc.sortableComponent\n*/\nimport ngeoBase from 'ngeo/index.js';\n\n/**\n * @type {!angular.Module}\n */\nconst exports = angular.module('ngeoSortable', []);\n\nngeoBase.module.requires.push(exports.name);\n\n\n/**\n * Provides a directive that allows drag-and-dropping DOM items between them.\n * It also changes the order of elements in the given array.\n *\n * It is typically used together with `ng-repeat`, for example for re-ordering\n * layers in a map.\n *\n * Example:\n *\n *     <ul ngeo-sortable=\"ctrl.layers\"\n *         ngeo-sortable-options=\"{handleClassName: 'ngeo-sortable-handle'}\">\n *       <li ng-repeat=\"layer in ctrl.layers\">\n *         <span class=\"ngeo-sortable-handle\">handle</span>{{layer.get('name')}}\n *       </li>\n *     </ul>\n *\n * The value of the \"ngeo-sortable\" attribute is an expression which evaluates\n * to an array (an array of layers in the above example). This is the array\n * that is re-ordered after a drag-and-drop.\n *\n * The element with the class \"ngeo-sortable-handle\" is the \"drag handle\".\n * It is required.\n *\n * This directives uses `$watchCollection` to watch the \"sortable\" array. So\n * if some outside code adds/removes elements to/from the \"sortable\" array,\n * the \"ngeoSortable\" directive will pick it up.\n *\n * See our live example: [../examples/layerorder.html](../examples/layerorder.html)\n *\n * @htmlAttribute {Array.<ol.layer.Base>} ngeo-sortable The layers to sort.\n * @htmlAttribute {!ngeox.miscSortableOptions} ngeo-sortable-options The options.\n * @htmlAttribute {Function(angular.JQLite, Array)?} ngeo-sortable-callback\n *     Callback function called after the move end. The Function will be called\n *     with the element and the sort array as arguments.\n * @htmlAttribute {Object?} ngeo-sortable-callback-ctx Context to apply at\n *     the call of the callback function.\n * @param {angular.$timeout} $timeout Angular timeout service.\n * @return {angular.Directive} The directive specs.\n * @ngInject\n * @ngdoc directive\n * @ngname ngeoSortable\n */\nexports.component_ = function($timeout) {\n  return {\n    restrict: 'A',\n    /**\n     * @param {angular.Scope} scope Scope.\n     * @param {angular.JQLite} element Element.\n     * @param {angular.Attributes} attrs Atttributes.\n     */\n    link: (scope, element, attrs) => {\n\n      const sortable = /** @type {Array} */\n              (scope.$eval(attrs['ngeoSortable'])) || [];\n      goog.asserts.assert(Array.isArray(sortable));\n\n      scope.$watchCollection(() => sortable, () => {\n        sortable.length && $timeout(resetUpDragDrop, 0);\n      });\n\n      const optionsObject = scope.$eval(attrs['ngeoSortableOptions']);\n      const options = getOptions(optionsObject);\n\n      const callbackFn = scope.$eval(attrs['ngeoSortableCallback']);\n      const callbackCtx = scope.$eval(attrs['ngeoSortableCallbackCtx']);\n\n      /**\n       * This function resets drag&drop for the list. It is called each\n       * time the sortable array changes (see $watchCollection above).\n       */\n      function resetUpDragDrop() {\n        // Add an index to the sortable to allow sorting of the\n        // underlying data.\n        const children = element.children();\n        for (let i = 0; i < children.length; ++i) {\n          angular.element(children[i]).data('idx', i);\n        }\n\n        const sortableElement = $(element);\n\n        const sortableOptions = {\n          'axis': 'y',\n          'classes': {\n            'ui-sortable-helper': options['draggerClassName']\n          }\n        };\n\n        // CSS class of the handle\n        if (options['handleClassName']) {\n          sortableOptions['handle'] = `.${options['handleClassName']}`;\n        }\n\n        // Placeholder for the item being dragged in the sortable list\n        if (options['placeholderClassName']) {\n          sortableOptions['placeholder'] = options['placeholderClassName'];\n          sortableOptions['forcePlaceholderSize'] = true;\n        }\n\n        sortableElement.sortable(sortableOptions);\n\n        // This event is triggered when the user stopped sorting and\n        // the DOM position (i.e. order in the sortable list) has changed.\n        sortableElement.on('sortupdate', (event, ui) => {\n          const oldIndex = $(ui.item[0]).data('idx');\n          const newIndex = ui.item.index();\n\n          // Update (data)-index on dom element to its new position\n          $(ui.item[0]).data('idx', newIndex);\n\n          // Move dragged item to new position\n          scope.$apply(() => {\n            sortable.splice(newIndex, 0, sortable.splice(oldIndex, 1)[0]);\n          });\n\n          // Call the callback function if it exists.\n          if (callbackFn instanceof Function) {\n            callbackFn.apply(callbackCtx, [element, sortable]);\n          }\n        });\n      }\n\n      /**\n       * @param {?} options Options after expression evaluation.\n       * @return {!ngeox.miscSortableOptions} Options object.\n       * @private\n       */\n      function getOptions(options) {\n        let ret;\n        const defaultHandleClassName = 'ngeo-sortable-handle';\n        if (options === undefined) {\n          ret = {'handleClassName': defaultHandleClassName};\n        } else {\n          if (options['handleClassName'] === undefined) {\n            options['handleClassName'] = defaultHandleClassName;\n          }\n          ret = /** @type {ngeox.miscSortableOptions} */ (options);\n        }\n        return ret;\n      }\n\n    }\n  };\n};\n\nexports.directive('ngeoSortable', exports.component_);\n\n\nexport default exports;\n\n\n\n// WEBPACK FOOTER //\n// ./src/misc/sortableComponent.js","/**\n * @module ngeo.misc.syncArrays\n*/\nimport googAsserts from 'goog/asserts.js';\nimport ngeoBase from 'ngeo/index.js';\n\n/**\n * Provides a function that synchronizes two arrays, arr1 and\n * arr2. arr2 is a subset of arr1, it includes the elements of arr1 that passes\n * the filter. When elements are added to/removed from arr1, arr2 is updated to\n * include the elements of arr1 that pass the filter. When the order of\n * elements in arr2 changes, arr1 is reordered to have the same order as arr2.\n *\n * This can for example be used to synchronize the array of layers in the map\n * with the array of selected layers, where layers may be added to/removed from\n * the map, and the order of selected layers may change.\n *\n *     let dereg = ngeoSyncArrays(map.getLayers().getArray(), selectedLayers,\n *         true, scope, function(layer) {\n *           // exclude the layer at index 0 in the map\n *           return map.getLayers().indexOf(layer) !== 0;\n *         });\n *\n * This will return a function that can be called to cancel synchronization.\n *\n * @param {Array.<T>} arr1 Array 1.\n * @param {Array.<T>} arr2 Array 2.\n * @param {boolean} reverse `true` if arr2 is in reverse order, `false`\n *     otherwise.\n * @param {angular.Scope} scope Angular scope. Used to watch arr1 and arr2\n *     using $watchCollection.\n * @param {function(T):boolean} filter Filter function.\n * @return {function()} Function to call to stop synchronization\n * @template T\n */\nconst exports = function(arr1, arr2, reverse, scope, filter) {\n\n\n  // Update arr2 when elements are added to, or removed from, arr1.\n\n  const dereg1 = scope.$watchCollection(() => arr1, () => {\n    let i, ii, j;\n    if (reverse) {\n      for (i = arr1.length - 1, j = 0; i >= 0; --i) {\n        if (filter(arr1[i])) {\n          arr2[j++] = arr1[i];\n        }\n      }\n    } else {\n      for (i = 0, ii = arr1.length, j = 0; i < ii; ++i) {\n        if (filter(arr1[i])) {\n          arr2[j++] = arr1[i];\n        }\n      }\n    }\n    arr2.length = j;\n  });\n\n\n  // Update arr1 when the order of elements changes in arr2.\n\n  const dereg2 = scope.$watchCollection(() => arr2, () => {\n    let i, ii, j;\n    if (reverse) {\n      for (i = 0, ii = arr1.length, j = arr2.length - 1; i < ii; ++i) {\n        if (filter(arr1[i])) {\n          arr1[i] = arr2[j--];\n        }\n      }\n      googAsserts.assert(j == -1);\n    } else {\n      for (i = 0, ii = arr1.length, j = 0; i < ii; ++i) {\n        if (filter(arr1[i])) {\n          arr1[i] = arr2[j++];\n        }\n      }\n      googAsserts.assert(j == arr2.length);\n    }\n  });\n\n  return function() {\n    dereg1();\n    dereg2();\n  };\n};\n\n\nexport default exports;\n\n\n\n// WEBPACK FOOTER //\n// ./src/misc/syncArrays.js","/**\n * @module ngeo.source.AsitVD\n*/\nimport olSourceWMTS from 'ol/source/WMTS.js';\nimport olTilegridWMTS from 'ol/tilegrid/WMTS.js';\n\n\n/**\n * @const {!Array.<number>}\n */\nconst asitVDResolutions = [\n  4000, 3750, 3500, 3250, 3000, 2750, 2500, 2250, 2000, 1750, 1500, 1250,\n  1000, 750, 650, 500, 250, 100, 50, 20, 10, 5, 2.5, 2, 1.5, 1, 0.5\n];\n\n\n/**\n * @const {ol.tilegrid.WMTS}\n */\nconst asitVDTileGrid = new olTilegridWMTS({\n  extent: [420000, 30000, 900000, 350000],\n  resolutions: asitVDResolutions,\n  matrixIds: asitVDResolutions.map((value, index) => `${index}`)\n});\n\n\n/**\n * Layer source for the ASIT VD tile server.\n * @see https://www.asitvd.ch/chercher/geoservices/fond-de-plan-asit-vd.html\n *\n */\nconst exports = class extends olSourceWMTS {\n\n  /**\n   * @param {ngeox.source.AsitVDOptions} options WMTS options.\n   */\n  constructor(options) {\n    super({\n      attributions: 'géodonnées &copy; Etat de Vaud & &copy; contributeurs OpenStreetMap',\n      url: 'https://ows{1-4}.asitvd.ch/wmts/1.0.0/{Layer}/default/default/0/' +\n        '21781/{TileMatrix}/{TileRow}/{TileCol}.png',\n      projection: 'EPSG:21781',\n      requestEncoding: 'REST',\n      layer: options.layer,\n      style: 'default',\n      matrixSet: '21781',\n      format: 'image/png',\n      tileGrid: asitVDTileGrid\n    });\n  }\n};\n\n\nexport default exports;\n\n\n\n// WEBPACK FOOTER //\n// ./src/source/AsitVD.js"],"sourceRoot":""}