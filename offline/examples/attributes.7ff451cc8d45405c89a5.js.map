{"version":3,"sources":["webpack:///./examples/attributes.js","webpack:///./src/format/XSDAttribute.js"],"names":["__webpack_require__","exports","module","angular","ngeoBase","name","ngeoMapModule","ngeoEditingAttributesComponent","MainController","$http","$timeout","$scope","_this","this","timeout_","attributes","disabled","feature","olFeature","kind","get","then","handleXSDAttributeGet_","bind","log","$watch","newValue","oldValue","appendLog","prototype","resp","ngeoFormatXSDAttribute","read","data","updateName","_this2","set","newMessage","controller","olBase","olFormatXML","call","inherits","source","readFromDocument","doc","googAsserts","assert","nodeType","Node","DOCUMENT_NODE","n","firstChild","nextSibling","ELEMENT_NODE","readFromNode","node","localName","elements","getElementsByTagName","length","attribute","i","ii","readFromElementNode_","push","getAttribute","assertString","alias","nillable","required","type","ngeoFormatAttribute","setGeometryType","setAttributeByXsdType_","enumerations","ngeoFormatAttributeType","SELECT","choices","restrictions","restrictionNode","maxLengths","maxLength","Number","BOOLEAN","DATE","DATETIME","TIME","NUMBER","numType","NumberType","FLOAT","INTEGER","TEXT","getGeometryAttribute","geomAttribute","GEOMETRY"],"mappings":"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","file":"attributes.7ff451cc8d45405c89a5.js","sourcesContent":["/**\n * @module app.attributes\n */\nconst exports = {};\n\nimport './common_dependencies.js';\nimport ngeoFormatXSDAttribute from 'ngeo/format/XSDAttribute.js';\n\n/** @suppress {extraRequire} */\nimport ngeoEditingAttributesComponent from 'ngeo/editing/attributesComponent.js';\n\nimport olFeature from 'ol/Feature.js';\nimport ngeoBase from 'ngeo/index.js';\nimport ngeoMapModule from 'ngeo/map/module.js';\n\n\n/** @type {!angular.Module} */\nexports.module = angular.module('app', [\n  ngeoBase.module.name,\n  ngeoMapModule.name,\n  ngeoEditingAttributesComponent.name,\n]);\n\n\n/**\n * @param {angular.$http} $http Angular http service.\n * @param {angular.$timeout} $timeout Angular timeout service.\n * @param {!angular.Scope} $scope Scope.\n * @ngInject\n * @constructor\n */\nexports.MainController = function($http, $timeout, $scope) {\n\n  /**\n   * @type {angular.$timeout}\n   * @private\n   */\n  this.timeout_ = $timeout;\n\n  /**\n   * @type {?Array.<ngeox.Attribute>}\n   * @export\n   */\n  this.attributes = null;\n\n  /**\n   * @type {boolean}\n   * @export\n   */\n  this.disabled = false;\n\n  /**\n   * @type {ol.Feature}\n   * @export\n   */\n  this.feature = new olFeature({\n    'name': 'A feature',\n    'kind': 'house'\n  });\n\n  $http.get('data/xsdattributes.xml').then(\n    this.handleXSDAttributeGet_.bind(this));\n\n  //\n  // Visual feedback for changes applied to feature:\n\n  /**\n   * @type {string}\n   * @export\n   */\n  this.log = '';\n\n  $scope.$watch(\n    () => this.feature.get('name'),\n    (newValue, oldValue) => {\n      if (newValue !== oldValue) {\n        this.appendLog(`name changed from '${oldValue}' to '${newValue}'`);\n      }\n    }\n  );\n\n  $scope.$watch(\n    () => this.feature.get('kind'),\n    (newValue, oldValue) => {\n      if (newValue !== oldValue) {\n        this.appendLog(`kind changed from '${oldValue}' to '${newValue}'`);\n      }\n    }\n  );\n};\n\n\n/**\n * @param {angular.$http.Response} resp Ajax response.\n * @return {Array.<ngeox.Attribute>} List of attributes.\n * @private\n */\nexports.MainController.prototype.handleXSDAttributeGet_ = function(resp) {\n  const format = new ngeoFormatXSDAttribute();\n  const attributes = format.read(resp.data);\n  this.attributes = attributes;\n  return attributes;\n};\n\n\n/**\n * @export\n */\nexports.MainController.prototype.updateName = function() {\n  this.timeout_(() => {\n    this.feature.set('name', 'An alternate name');\n  }, 0);\n};\n\n/**\n * @param {string} newMessage New message to add to log.\n */\nexports.MainController.prototype.appendLog = function(newMessage) {\n  this.log = `${newMessage}\\n${this.log}`;\n};\n\n\nexports.module.controller('MainController', exports.MainController);\n\n\nexport default exports;\n\n\n\n// WEBPACK FOOTER //\n// ./examples/attributes.js","/**\n * @module ngeo.format.XSDAttribute\n */\nimport googAsserts from 'goog/asserts.js';\nimport ngeoBase from 'ngeo/index.js';\nimport ngeoFormatAttribute from 'ngeo/format/Attribute.js';\nimport ngeoFormatAttributeType from 'ngeo/format/AttributeType.js';\nimport * as olBase from 'ol/index.js';\nimport olFormatXML from 'ol/format/XML.js';\n\n/**\n * @classdesc\n * Reads attributes that are defined in XSD format and return them as a list.\n *\n * @constructor\n * @struct\n * @extends {ol.format.XML}\n */\nconst exports = function() {\n  olFormatXML.call(this);\n};\n\nolBase.inherits(exports, olFormatXML);\n\n\n/**\n * @param {Document|Node|string} source Source.\n * @return {Array.<ngeox.Attribute>} The parsed result.\n * @override\n */\nexports.prototype.read = function(source) {\n  return (\n    /** @type {Array.<ngeox.Attribute>} */ olFormatXML.prototype.read.call(this, source)\n  );\n};\n\n\n/**\n * @param {Document} doc Document.\n * @return {Array.<ngeox.Attribute>} List of attributes.\n * @override\n */\nexports.prototype.readFromDocument = function(doc) {\n  googAsserts.assert(doc.nodeType == Node.DOCUMENT_NODE,\n    'doc.nodeType should be DOCUMENT');\n  for (let n = doc.firstChild; n; n = n.nextSibling) {\n    if (n.nodeType == Node.ELEMENT_NODE) {\n      return this.readFromNode(n);\n    }\n  }\n  return null;\n};\n\n\n/**\n * @param {Node} node Node.\n * @return {Array.<ngeox.Attribute>} List of attributes.\n * @override\n */\nexports.prototype.readFromNode = function(node) {\n  googAsserts.assert(node.nodeType == Node.ELEMENT_NODE,\n    'node.nodeType should be ELEMENT');\n  googAsserts.assert(node.localName == 'schema',\n    'localName should be schema');\n\n  let elements = node.getElementsByTagName('element');\n  if (!elements.length) {\n    elements = node.getElementsByTagName('xsd:element');\n  }\n  const attributes = [];\n\n  let attribute;\n  for (let i = 0, ii = elements.length; i < ii; i++) {\n    attribute = this.readFromElementNode_(elements[i]);\n    if (attribute) {\n      attributes.push(attribute);\n    }\n  }\n\n  return attributes;\n};\n\n\n/**\n * @param {Node} node Node.\n * @return {?ngeox.Attribute} An attribute object.\n * @private\n */\nexports.prototype.readFromElementNode_ = function(node) {\n\n  const name = node.getAttribute('name');\n  googAsserts.assertString(name, 'name should be defined in element node.');\n\n  const alias = node.getAttribute('alias');\n  const nillable = node.getAttribute('nillable');\n  const required = !(nillable === true || nillable === 'true');\n\n  const attribute = {\n    name,\n    alias,\n    required\n  };\n\n  const type = node.getAttribute('type');\n  if (type) {\n    if (!ngeoFormatAttribute.setGeometryType(attribute, type)) {\n      this.setAttributeByXsdType_(attribute, type);\n    }\n  } else {\n\n    // Attribute has no type defined on 'element' node.  Try:\n\n    // (1) Enumerations\n    let enumerations = node.getElementsByTagName('enumeration');\n    if (!enumerations.length) {\n      enumerations = node.getElementsByTagName('xsd:enumeration');\n    }\n    if (enumerations.length) {\n      attribute.type = ngeoFormatAttributeType.SELECT;\n      const choices = [];\n      for (let i = 0, ii = enumerations.length; i < ii; i++) {\n        choices.push(enumerations[i].getAttribute('value'));\n      }\n      attribute.choices = choices;\n    } else {\n      // (2) Other types with restrictions\n      let restrictions = node.getElementsByTagName('restriction');\n      if (!restrictions.length) {\n        restrictions = node.getElementsByTagName('xsd:restriction');\n      }\n      if (restrictions.length && restrictions[0]) {\n        const restrictionNode = restrictions[0];\n        this.setAttributeByXsdType_(\n          attribute,\n          restrictionNode.getAttribute('base')\n        );\n        // MaxLength\n        let maxLengths = node.getElementsByTagName('maxLength');\n        if (!maxLengths.length) {\n          maxLengths = node.getElementsByTagName('xsd:maxLength');\n        }\n        if (maxLengths.length && maxLengths[0]) {\n          attribute.maxLength = Number(maxLengths[0].getAttribute('value'));\n        }\n      }\n    }\n  }\n\n  if (!attribute.type) {\n    return null;\n  }\n\n  googAsserts.assert(attribute.type);\n\n  return attribute;\n};\n\n\n/**\n * Set the `type` and `numType` properties of an attribute depending on the\n * given xsdType.\n *\n * @param {ngeox.AttributeBase} attribute Attribute.\n * @param {string} type The xsd type.\n * @private\n */\nexports.prototype.setAttributeByXsdType_ = function(\n  attribute, type\n) {\n  if (type === 'xsd:boolean') {\n    attribute.type = ngeoFormatAttributeType.BOOLEAN;\n  } else if (type === 'xsd:date') {\n    attribute.type = ngeoFormatAttributeType.DATE;\n  } else if (type === 'xsd:dateTime') {\n    attribute.type = ngeoFormatAttributeType.DATETIME;\n  } else if (type === 'xsd:time') {\n    attribute.type = ngeoFormatAttributeType.TIME;\n  } else if (type === 'xsd:decimal') {\n    attribute.type = ngeoFormatAttributeType.NUMBER;\n    attribute.numType = exports.NumberType.FLOAT;\n  } else if (type === 'xsd:integer') {\n    attribute.type = ngeoFormatAttributeType.NUMBER;\n    attribute.numType = exports.NumberType.INTEGER;\n  } else if (type === 'xsd:string') {\n    attribute.type = ngeoFormatAttributeType.TEXT;\n  }\n};\n\n\n/**\n * Returns the first geometry attribute among a given list of attributes.\n * @param {Array.<ngeox.Attribute>} attributes The list of attributes.\n * @return {?ngeox.Attribute} A geometry attribute object.\n */\nexports.getGeometryAttribute = function(attributes) {\n  let geomAttribute = null;\n  for (let i = 0, ii = attributes.length; i < ii; i++) {\n    if (attributes[i].type === ngeoFormatAttributeType.GEOMETRY) {\n      geomAttribute = attributes[i];\n      break;\n    }\n  }\n  return geomAttribute;\n};\n\n\n/**\n * @enum {string}\n * @export\n */\nexports.NumberType = {\n  /**\n   * @type {string}\n   * @export\n   */\n  FLOAT: 'float',\n  /**\n   * @type {string}\n   * @export\n   */\n  INTEGER: 'integer'\n};\n\n\nexport default exports;\n\n\n\n// WEBPACK FOOTER //\n// ./src/format/XSDAttribute.js"],"sourceRoot":""}