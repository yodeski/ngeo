{"version":3,"sources":["webpack:///./src/misc/WMSTime.js","webpack:///./src/misc/Time.js","webpack:///./contribs/gmf/examples/timeslider.js","webpack:///./contribs/gmf/src/layertree/timeSliderComponent.js","webpack:///./node_modules/angular-ui-slider/src/index.js","webpack:///./node_modules/angular-ui-slider/src/slider.js"],"names":["__webpack_require__","olBase","exports","$filter","gettextCatalog","this","$filter_","gettextCatalog_","ngeoMiscTime","call","inherits","prototype","formatTimeValue","time","resolution","opt_useISOFormat","opt_toUTC","date","Date","utc","undefined","yearResolution","monthResolution","dayResolution","getString","toISOString","replace","formatWMSTimeParam","wmsTimeProperty","times","googAsserts","assert","mode","end","start","module","angular","name","service","ngeoBase","requires","push","_index","getOptions","minDate","minValue","maxDate","maxValue","minDefaultDate","minDefValue","maxDefaultDate","maxDefValue","defaultValues","getTime","values","getUTCDate","localDate","getUTCFullYear","getUTCMonth","gmfBase","gmfLayertreeTimeSliderComponent","ngeoMiscWMSTime","constant","MainController","$scope","ngeoWMSTime","ngeoWMSTime_","wmsTimeRangeMode","widget","interval","wmsTimeValueMode","sliderValue","sliderRangeValue","onDateSelected","$digest","onDateRangeSelected","controller","directive_","$timeout","scope","bindToController","restrict","templateUrl","baseModuleTemplateUrl","link","pre","element","attrs","ctrl","computeDates_","e","sliderUi","sDate","eDate","wmstime","getClosestValue_","dates","value","$apply","init","sliderOptions","directive","Controller_","isModeRange","timeValueList","getTimeValueList_","initialOptions_","range","min","max","wmsTime","forEach","endDate","setFullYear","getFullYear","setMonth","getMonth","getDate","setSeconds","getSeconds","i","nextDate","timestamp","index","leftIndex","rightIndex","length","Math","floor","leftDistance","abs","rightDistance","targetDate","startDate","bestDate","bestDistance","next","distance","getLocalizedDate","$","uiSliderConfig","require","compile","elm","ngModel","parseNumber","n","decimals","parseFloat","parseInt","directiveOptions","copy","$eval","uiSlider","options","extend","prevRangeValues","properties","useDecimals","isUndefined","updateOn","isDefined","isArray","$viewValue","console","warn","property","slider","noop","destroy","hasClass","$observe","newVal","$render","$watch","bind","event","ui","valuesChanged","boundedValues","slice","lowerBound","upperBound","boundedValue","$setViewValue","handle","find","text","setTimeout","method","isNaN","Array","isString","match","valueArr","split","Number","each","tipElm","$on","one","post","total","left","addClass","appendTo","css","handles","append"],"mappings":"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","file":"timeslider.882f0d66ebd3cc8306af.js","sourcesContent":["/**\n * @module ngeo.misc.WMSTime\n */\nimport googAsserts from 'goog/asserts.js';\nimport ngeoBase from 'ngeo/index.js';\nimport ngeoMiscTime from 'ngeo/misc/Time.js';\nimport * as olBase from 'ol/index.js';\n\n/**\n * ngeo - WMS time service\n * @extends {ngeo.misc.Time}\n * @param {angular.$filter} $filter angular filter service.\n * @param {!angularGettext.Catalog} gettextCatalog service.\n * @constructor\n * @struct\n * @ngInject\n * @ngdoc service\n * @ngname ngeoWMSTime\n */\nconst exports = function($filter, gettextCatalog) {\n\n  /**\n   * @private\n   * @type {angular.$filter}\n   */\n  this.$filter_ = $filter;\n\n  /**\n   * @type {!angularGettext.Catalog}\n   * @private\n   */\n  this.gettextCatalog_ = gettextCatalog;\n\n  ngeoMiscTime.call(this);\n};\n\nolBase.inherits(exports, ngeoMiscTime);\n\n\n/**\n * Format time regarding a resolution\n * @param  {number} time (in ms format) timestamp to format\n * @param  {(ngeox.TimePropertyResolutionEnum|undefined)} resolution resolution to use\n * @param  {boolean=} opt_useISOFormat True to a ISO-8601 date string that can be used\n *     as a WMS-T Parameter. Otherwise, use a localized date format.\n * @param  {boolean=} opt_toUTC to get the UTC date\n * @return {string} Date string regarding the resolution.\n */\nexports.prototype.formatTimeValue = function(time, resolution, opt_useISOFormat, opt_toUTC) {\n  const date = new Date(time);\n  const utc = opt_toUTC ? 'UTC' : undefined;\n\n  // ISO-8601 format to use date as a WMS-T Parameter.\n  let yearResolution = 'yyyy';\n  let monthResolution = 'yyyy-MM';\n  let dayResolution = 'yyyy-MM-dd';\n\n  // Localized format.\n  if (!opt_useISOFormat) {\n    const gettextCatalog = this.gettextCatalog_;\n    yearResolution = gettextCatalog.getString('yyyy');\n    monthResolution = gettextCatalog.getString('M/yyyy');\n    dayResolution = gettextCatalog.getString('M/d/yyyy');\n  }\n\n  switch (resolution) {\n    case 'year':\n      return this.$filter_('date')(date, yearResolution, utc);\n    case 'month':\n      return this.$filter_('date')(date, monthResolution, utc);\n    case 'day':\n      return this.$filter_('date')(date, dayResolution, utc);\n    default:\n      //case \"second\":\n      return date.toISOString().replace(/\\.\\d{3}/, '');\n  }\n};\n\n\n/**\n * Format time to be used as a WMS Time query parameter\n * @param  {ngeox.TimeProperty} wmsTimeProperty a wmstime property from a node\n * @param  {{start : number, end : (number|undefined)}} times start & end time selected (in ms format)\n * @param  {boolean=} opt_toUTC to get the UTC date\n * @return {string} ISO-8601 date string ready to be used as a query parameter for a\n * WMS request\n * @export\n */\nexports.prototype.formatWMSTimeParam = function(wmsTimeProperty, times, opt_toUTC) {\n  googAsserts.assert(wmsTimeProperty.resolution !== undefined);\n  if (wmsTimeProperty.mode === 'range') {\n    googAsserts.assert(times.end !== undefined);\n    return (\n      `${this.formatTimeValue(times.start, wmsTimeProperty.resolution, true, opt_toUTC)}/${\n        this.formatTimeValue(times.end, wmsTimeProperty.resolution, true, opt_toUTC)}`\n    );\n  } else {\n    return this.formatTimeValue(times.start, wmsTimeProperty.resolution, true, opt_toUTC);\n  }\n};\n\n\n/**\n * @type {!angular.Module}\n */\nexports.module = angular.module('ngeoWMSTime', [\n  ngeoMiscTime.module.name,\n]);\nexports.module.service('ngeoWMSTime', exports);\nngeoBase.module.requires.push(exports.module.name);\n\n\nexport default exports;\n\n\n\n// WEBPACK FOOTER //\n// ./src/misc/WMSTime.js","/**\n * @module ngeo.misc.Time\n */\nimport ngeoBase from 'ngeo/index.js';\n\n/**\n * ngeo - Time service\n * @constructor\n * @struct\n * @ngInject\n * @ngdoc service\n * @ngname ngeoTime\n */\nconst exports = function() {};\n\n\n/**\n * Get options regarding the time property of a node;\n *\n * @param {ngeox.TimeProperty} time the time property of a node\n * @return {{\n *  minDate : number,\n *  maxDate : number,\n *  values : (Array<number>|number)\n * }} - Configuration for the UI components\n * @export\n */\nexports.prototype.getOptions = function(time) {\n\n  const minDate = new Date(time.minValue);\n  const maxDate = new Date(time.maxValue);\n\n  const minDefaultDate = (time.minDefValue) ?\n    new Date(time.minDefValue) : minDate;\n  const maxDefaultDate = (time.maxDefValue) ?\n    new Date(time.maxDefValue) : maxDate;\n\n  const defaultValues = (time.mode === 'range') ?\n    [minDefaultDate.getTime(), maxDefaultDate.getTime()] :\n    minDefaultDate.getTime();\n\n  return {\n    minDate: minDate.getTime(),\n    maxDate: maxDate.getTime(),\n    values: defaultValues\n  };\n};\n\n\n/**\n * Time.prototype.getUTCDate - Get UTC date from a local date object\n *\n * @param  {Object} localDate loacl date object in\n * @return {Object} UTC date\n * @export\n */\nexports.prototype.getUTCDate = function(localDate) {\n  return new Date(\n    localDate.getUTCFullYear(),\n    localDate.getUTCMonth(),\n    localDate.getUTCDate());\n};\n\n\n/**\n * @type {!angular.Module}\n */\nexports.module = angular.module('ngeoTime', []);\nexports.module.service('ngeoTime', exports);\nngeoBase.module.requires.push(exports.module.name);\n\n\nexport default exports;\n\n\n\n// WEBPACK FOOTER //\n// ./src/misc/Time.js","/**\n * @module gmfapp.timeslider\n */\nconst exports = {};\n\nimport './timeslider.css';\nimport './common_dependencies.js';\nimport gmfBase from 'gmf/index.js';\n\nimport gmfLayertreeTimeSliderComponent from 'gmf/layertree/timeSliderComponent.js';\nimport ngeoMiscWMSTime from 'ngeo/misc/WMSTime.js';\n\n\n/** @type {!angular.Module} **/\nexports.module = angular.module('gmfapp', [\n  gmfBase.module.name,\n  gmfLayertreeTimeSliderComponent.name,\n  ngeoMiscWMSTime.module.name,\n]);\n\nexports.constant('angularLocaleScript', '../build/angular-locale_{{locale}}.js');\n\n\n/**\n * @constructor\n * @param {!angular.Scope} $scope Angular scope.\n * @param {!ngeo.misc.WMSTime} ngeoWMSTime wmstime service.\n * @ngInject\n */\nexports.MainController = function($scope, ngeoWMSTime) {\n\n  /**\n   * @type {ngeo.misc.WMSTime}\n   * @private\n   */\n  this.ngeoWMSTime_ = ngeoWMSTime;\n\n  /**\n   * @type {ngeox.TimeProperty}\n   * @export\n   */\n  this.wmsTimeRangeMode = {\n    widget: /** @type {ngeox.TimePropertyWidgetEnum} */ ('slider'),\n    maxValue: '2013-12-31T00:00:00Z',\n    minValue: '2006-01-01T00:00:00Z',\n    maxDefValue: null,\n    minDefValue: null,\n    resolution: /** @type {ngeox.TimePropertyResolutionEnum}*/ ('day'),\n    mode: /** @type {ngeox.TimePropertyModeEnum} */('range'),\n    interval: [0, 1, 0, 0]\n  };\n\n  /**\n   * @type {ngeox.TimeProperty}\n   * @export\n   */\n  this.wmsTimeValueMode = {\n    widget: /** @type {ngeox.TimePropertyWidgetEnum} */ ('slider'),\n    maxValue: '2015-12-31T00:00:00Z',\n    minValue: '2014-01-01T00:00:00Z',\n    maxDefValue: null,\n    minDefValue: null,\n    resolution: /** @type {ngeox.TimePropertyResolutionEnum}*/ ('year'),\n    mode: /** @type {ngeox.TimePropertyModeEnum} */ ('value'),\n    interval: [0, 0, 1, 0]\n  };\n\n  /**\n   * @type {string}\n   * @export\n   */\n  this.sliderValue;\n\n  /**\n   * @type {string}\n   * @export\n   */\n  this.sliderRangeValue;\n\n  this.onDateSelected = function(date) {\n    this.sliderValue = this.ngeoWMSTime_.formatWMSTimeParam(this.wmsTimeValueMode, date);\n    $scope.$digest();\n  };\n\n  this.onDateRangeSelected = function(date) {\n    this.sliderRangeValue = this.ngeoWMSTime_.formatWMSTimeParam(this.wmsTimeRangeMode, date);\n    $scope.$digest();\n  };\n\n};\n\n\nexports.module.controller('MainController', exports.MainController);\n\n\nexport default exports;\n\n\n\n// WEBPACK FOOTER //\n// ./contribs/gmf/examples/timeslider.js","/**\n * @module gmf.layertree.timeSliderComponent\n */\nimport gmfBase from 'gmf/index.js';\nimport ngeoMiscWMSTime from 'ngeo/misc/WMSTime.js';\n\nimport 'angular-ui-slider';\n\n/**\n * @type {!angular.Module}\n */\nconst exports = angular.module('gmfLayertreeTimeSliderComponent', [\n  ngeoMiscWMSTime.module.name,\n  'ui.slider',\n]);\n\ngmfBase.module.requires.push(exports.name);\n\n\n/**\n * Provide a directive to select a single date or a range of dates with a slider\n * Example:\n *\n *      <gmf-time-slider\n *          gmf-time-slider-time=\"{\n *            maxValue: '2013-12-31T00:00:00Z',\n *            minValue: '2006-01-01T00:00:00Z',\n *            mode: 'range'}\"\n *          gmf-time-slider-on-date-selected=\"ctrl.onDateSelected(time)\">\n *      </gmf-time-slider>\n *\n * @htmlAttribute {ngeox.TimeProperty} gmf-time-slider-time parameter for initialization.\n * @htmlAttribute {function()} gmf-time-slider-on-date-selected Expresion evaluated after\n * date(s) changed\n * @param {angular.$timeout} $timeout angular timeout service\n * @param {angular.$filter} $filter angular filter service\n * @return {angular.Directive} The directive specs.\n * @ngInject\n * @ngdoc directive\n * @ngname gmfTimeSlider\n */\nexports.directive_ = function($timeout, $filter) {\n  return {\n    scope: {\n      onDateSelected: '&gmfTimeSliderOnDateSelected',\n      time: '=gmfTimeSliderTime'\n    },\n    bindToController: true,\n    controller: 'gmfTimeSliderController as sliderCtrl',\n    restrict: 'AE',\n    templateUrl: `${gmfBase.baseModuleTemplateUrl}/layertree/timesliderComponent.html`,\n    link: /** @type {!angular.LinkingFunctions} */ ({\n      pre: function preLink(scope, element, attrs, ctrl) {\n        ctrl.init();\n\n        ctrl.sliderOptions['stop'] = onSliderReleased_;\n        ctrl.sliderOptions['slide'] = computeDates_;\n\n        function onSliderReleased_(e, sliderUi) {\n          ctrl.onDateSelected({\n            time: computeDates_(e, sliderUi)\n          });\n          scope.$apply();\n        }\n\n        function computeDates_(e, sliderUi) {\n          let sDate, eDate, wmstime;\n          if (sliderUi.values) {\n            sDate = new Date(ctrl.getClosestValue_(sliderUi.values[0]));\n            eDate = new Date(ctrl.getClosestValue_(sliderUi.values[1]));\n            ctrl.dates = [sDate, eDate];\n            wmstime = {\n              start: sDate.getTime(),\n              end: eDate.getTime()\n            };\n          } else {\n            sDate = new Date(ctrl.getClosestValue_(sliderUi.value));\n            ctrl.dates = sDate;\n            wmstime = {\n              start: sDate.getTime()\n            };\n          }\n          scope.$apply();\n          return wmstime;\n        }\n      }\n    })\n  };\n};\n\n\nexports.directive('gmfTimeSlider',\n  exports.directive_);\n\n\n/**\n * TimeSliderController - directive controller\n * @param {!angular.Scope} $scope Angular scope.\n * @param {ngeo.misc.WMSTime} ngeoWMSTime WMSTime service.\n * @constructor\n * @private\n * @ngInject\n * @ngdoc controller\n * @ngname gmfTimeSliderController\n */\nexports.Controller_ = function($scope, ngeoWMSTime) {\n\n  /**\n   * @type {ngeo.misc.WMSTime}\n   * @private\n   */\n  this.ngeoWMSTime_ = ngeoWMSTime;\n\n  /**\n   * Function called after date(s) changed/selected\n   * @function\n   * @export\n   */\n  this.onDateSelected;\n\n\n  /**\n   * A time object for directive initialization\n   * @type {ngeox.TimeProperty}\n   * @export\n   */\n  this.time;\n\n  /**\n   * If the component is used to select a date range\n   * @type {boolean}\n   * @export\n   */\n  this.isModeRange;\n\n  /**\n   * Minimal value of the slider (time in ms)\n   * @type {number}\n   * @export\n   */\n  this.minValue;\n\n  /**\n   * Maximal value of the slider (time in ms)\n   * @type {number}\n   * @export\n   */\n  this.maxValue;\n\n  /**\n   * Used when WMS time object has a property 'values' instead of an interval\n   * @type (?Array<number>)\n   */\n  this.timeValueList;\n\n  /**\n   * Default Slider options (used by ui-slider directive)\n   * @type {{\n   *  range : boolean,\n   *  min : number,\n   *  max : number\n   * }}\n   * @export\n   */\n  this.sliderOptions;\n\n  /**\n   * Model for the ui-slider directive (date in ms format)\n   * @type {Array.<number>|number}\n   * @export\n   */\n  this.dates;\n};\n\n\n/**\n * Initialise the controller.\n */\nexports.Controller_.prototype.init = function() {\n  this.timeValueList = this.getTimeValueList_();\n\n  // Fetch the initial options for the component\n  const initialOptions_ = this.ngeoWMSTime_.getOptions(this.time);\n  this.isModeRange = this.time.mode === 'range';\n  this.minValue = initialOptions_.minDate;\n  this.maxValue = initialOptions_.maxDate;\n  this.dates = this.isModeRange ? [initialOptions_.values[0], initialOptions_.values[1]] :\n    initialOptions_.values;\n  this.sliderOptions = {\n    range: this.isModeRange,\n    min: this.minValue,\n    max: this.maxValue\n  };\n};\n\n/**\n * TimeSliderController.prototype.getTimeValueList_ - Get a list of time value instead\n * of using the wmstime interval as a list of possibles values\n * @private\n * @return {Array<number>}  - List of timestamp representing possible values\n */\nexports.Controller_.prototype.getTimeValueList_ = function() {\n  const wmsTime = this.time;\n  let timeValueList = null;\n  const minDate = new Date(this.minValue);\n  const maxDate = new Date(this.maxValue);\n\n  if (wmsTime.values) {\n    timeValueList = [];\n    wmsTime.values.forEach((date) => {\n      timeValueList.push(new Date(date).getTime());\n    });\n  } else {\n    const maxNbValues = 1024;\n    const endDate = new Date(minDate.getTime());\n    endDate.setFullYear(minDate.getFullYear() + maxNbValues * wmsTime.interval[0]);\n    endDate.setMonth(minDate.getMonth() + maxNbValues * wmsTime.interval[1],\n      minDate.getDate() + maxNbValues * wmsTime.interval[2]);\n    endDate.setSeconds(minDate.getSeconds() + maxNbValues * wmsTime.interval[3]);\n\n    if (endDate > maxDate) {\n      // Transform interval to a list of values when the number\n      // of values is below a threshold (maxNbValues)\n      timeValueList = [];\n      for (let i = 0; ; i++) {\n        const nextDate = new Date(minDate.getTime());\n        nextDate.setFullYear(minDate.getFullYear() + i * wmsTime.interval[0]);\n        nextDate.setMonth(minDate.getMonth() + i * wmsTime.interval[1],\n          minDate.getDate() + i * wmsTime.interval[2]);\n        nextDate.setSeconds(minDate.getSeconds() + i * wmsTime.interval[3]);\n        if (nextDate <= maxDate) {\n          timeValueList.push(nextDate.getTime());\n        } else {\n          break;\n        }\n      }\n    }\n  }\n  return timeValueList;\n};\n\n\n/**\n * Compute the closest available date from the given timestamp\n * @param  {number} timestamp selected datetime (in ms format)\n * @return {number} the closest available datetime (in ms format) from the timestamp\n * @private\n */\nexports.Controller_.prototype.getClosestValue_ = function(timestamp) {\n  if (timestamp <= this.minValue) {\n    return this.minValue;\n  }\n\n  if (timestamp >= this.maxValue) {\n    return this.maxValue;\n  }\n\n  if (this.timeValueList) {\n    // Time stops are defined as a list of values\n    let index;\n    let leftIndex = 0;\n    let rightIndex = this.timeValueList.length - 1;\n\n    while ((rightIndex - leftIndex) > 1) {\n      index = Math.floor((leftIndex + rightIndex) / 2);\n      if (this.timeValueList[index] >= timestamp) {\n        rightIndex = index;\n      } else {\n        leftIndex = index;\n      }\n    }\n\n    const leftDistance = Math.abs(this.timeValueList[leftIndex] - timestamp);\n    const rightDistance = Math.abs(this.timeValueList[rightIndex] - timestamp);\n\n    return this.timeValueList[leftDistance < rightDistance ? leftIndex : rightIndex];\n  } else {\n    // Time stops are defined by a start date plus an interval\n    const targetDate = new Date(timestamp);\n    const startDate = new Date(this.minValue);\n    let bestDate = new Date(this.minValue);\n    const maxDate = new Date(this.maxValue);\n    let bestDistance = Math.abs(targetDate - bestDate);\n\n    for (let i = 1; ; i++) {\n      // The start date should always be used as a reference\n      // because adding a month twice could differ from adding\n      // two months at once\n      const next = new Date(startDate.getTime());\n      next.setFullYear(startDate.getFullYear() + i * this.time.interval[0]);\n      next.setMonth(startDate.getMonth() + i *  this.time.interval[1],\n        startDate.getDate() + i * this.time.interval[2]);\n      next.setSeconds(startDate.getSeconds() + i * this.time.interval[3]);\n\n      if (next > maxDate) {\n        break;\n      }\n\n      const distance = Math.abs(targetDate - next);\n      if (distance <= bestDistance) {\n        bestDate = next;\n        bestDistance = distance;\n      } else {\n        break;\n      }\n    }\n\n    return bestDate.getTime();\n  }\n};\n\n\n/**\n * Format and localize time regarding a resolution.\n * @param {number} time (in ms format) timestamp to format and localize.\n * @return {string} Localized date string regarding the resolution.\n * @export\n */\nexports.Controller_.prototype.getLocalizedDate = function(time) {\n  return this.ngeoWMSTime_.formatTimeValue(time, this.time.resolution);\n};\n\n\nexports.controller('gmfTimeSliderController',\n  exports.Controller_);\n\n\nexport default exports;\n\n\n\n// WEBPACK FOOTER //\n// ./contribs/gmf/src/layertree/timeSliderComponent.js","require('./slider')\nmodule.exports = 'ui.slider'\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/angular-ui-slider/src/index.js\n// module id = 526\n// module chunks = 26","/*\n jQuery UI Slider plugin wrapper\n*/\nangular.module('ui.slider', []).value('uiSliderConfig',{}).directive('uiSlider', ['uiSliderConfig', '$timeout', function(uiSliderConfig, $timeout) {\n    uiSliderConfig = uiSliderConfig || {};\n    return {\n        require: 'ngModel',\n        compile: function() {\n            var preLink = function (scope, elm, attrs, ngModel) {\n\n                function parseNumber(n, decimals) {\n                    return (decimals) ? parseFloat(n) : parseInt(n, 10);\n                }\n\n                var directiveOptions = angular.copy(scope.$eval(attrs.uiSlider));\n                var options = angular.extend(directiveOptions || {}, uiSliderConfig);\n                // Object holding range values\n                var prevRangeValues = {\n                    min: null,\n                    max: null\n                };\n\n                // convenience properties\n                var properties = ['min', 'max', 'step', 'lowerBound', 'upperBound'];\n                var useDecimals = (!angular.isUndefined(attrs.useDecimals)) ? true : false;\n                var updateOn = (angular.isDefined(options['updateOn'])) ? options['updateOn'] : 'slide'\n\n                var init = function() {\n                    // When ngModel is assigned an array of values then range is expected to be true.\n                    // Warn user and change range to true else an error occurs when trying to drag handle\n                    if (angular.isArray(ngModel.$viewValue) && options.range !== true) {\n                        console.warn('Change your range option of ui-slider. When assigning ngModel an array of values then the range option should be set to true.');\n                        options.range = true;\n                    }\n\n                    // Ensure the convenience properties are passed as options if they're defined\n                    // This avoids init ordering issues where the slider's initial state (eg handle\n                    // position) is calculated using widget defaults\n                    // Note the properties take precedence over any duplicates in options\n                    angular.forEach(properties, function(property) {\n                        if (angular.isDefined(attrs[property])) {\n                            options[property] = parseNumber(attrs[property], useDecimals);\n                        }\n                    });\n\n                    elm.slider(options);\n                    init = angular.noop;\n                };\n\n                // Find out if decimals are to be used for slider\n                angular.forEach(properties, function(property) {\n                    // support {{}} and watch for updates\n                    attrs.$observe(property, function(newVal) {\n                        if (!!newVal) {\n                            init();\n                            options[property] = parseNumber(newVal, useDecimals);\n                            elm.slider('option', property, parseNumber(newVal, useDecimals));\n                            ngModel.$render();\n                        }\n                    });\n                });\n                attrs.$observe('disabled', function(newVal) {\n                    init();\n                    elm.slider('option', 'disabled', !!newVal);\n                });\n\n                // Watch ui-slider (byVal) for changes and update\n                scope.$watch(attrs.uiSlider, function(newVal) {\n                    init();\n                    if(newVal !== undefined) {\n                      elm.slider('option', newVal);\n                    }\n                }, true);\n\n                // Late-bind to prevent compiler clobbering\n                $timeout(init, 0, true);\n\n                // Update model value from slider\n                elm.bind(updateOn, function(event, ui) {\n                    var valuesChanged;\n\n                    if (ui.values) {\n                        var boundedValues = ui.values.slice();\n\n                        if (options.lowerBound && boundedValues[0] < options.lowerBound) {\n                            boundedValues[0] = Math.max(boundedValues[0], options.lowerBound);\n                        }\n                        if (options.upperBound && boundedValues[1] > options.upperBound) {\n                            boundedValues[1] = Math.min(boundedValues[1], options.upperBound);\n                        }\n\n                        if (boundedValues[0] !== ui.values[0] || boundedValues[1] !== ui.values[1]) {\n                            valuesChanged = true;\n                            ui.values = boundedValues;\n                        }\n                    } else {\n                        var boundedValue = ui.value;\n\n                        if (options.lowerBound && boundedValue < options.lowerBound) {\n                            boundedValue = Math.max(boundedValue, options.lowerBound);\n                        }\n                        if (options.upperBound && boundedValue > options.upperBound) {\n                            boundedValue = Math.min(boundedValue, options.upperBound);\n                        }\n\n                        if (boundedValue !== ui.value) {\n                            valuesChanged = true;\n                            ui.value = boundedValue;\n                        }\n                    }\n\n\n                    ngModel.$setViewValue(ui.values || ui.value);\n                    $(ui.handle).find('.ui-slider-tip').text(ui.value);\n                    scope.$apply();\n\n                    if (valuesChanged) {\n                        setTimeout(function() {\n                            elm.slider('value', ui.values || ui.value);\n                        }, 0);\n\n                        return false;\n                    }\n                });\n\n                // Update slider from model value\n                ngModel.$render = function() {\n                    init();\n                    var method = options.range === true ? 'values' : 'value';\n\n                    if (options.range !== true && isNaN(ngModel.$viewValue) && !(ngModel.$viewValue instanceof Array)) {\n                        ngModel.$viewValue = 0;\n                    }\n                    else if (options.range && !angular.isDefined(ngModel.$viewValue)) {\n                            ngModel.$viewValue = [0,0];\n                    }\n\n                    // Do some sanity check of range values\n                    if (options.range === true) {\n                        // previously, the model was a string b/c it was in a text input, need to convert to a array.\n                        // make sure input exists, comma exists once, and it is a string.\n                        if (ngModel.$viewValue && angular.isString(ngModel.$viewValue) && (ngModel.$viewValue.match(/,/g) || []).length === 1) {\n                            // transform string model into array.\n                            var valueArr = ngModel.$viewValue.split(',');\n                            ngModel.$viewValue = [Number(valueArr[0]), Number(valueArr[1])];\n                        }\n                        // Check outer bounds for min and max values\n                        if (angular.isDefined(options.min) && options.min > ngModel.$viewValue[0]) {\n                            ngModel.$viewValue[0] = options.min;\n                        }\n                        if (angular.isDefined(options.max) && options.max < ngModel.$viewValue[1]) {\n                            ngModel.$viewValue[1] = options.max;\n                        }\n\n                        // Check min and max range values\n                        if (ngModel.$viewValue[0] > ngModel.$viewValue[1]) {\n                            // Min value should be less to equal to max value\n                            if (prevRangeValues.min >= ngModel.$viewValue[1]) {\n                                ngModel.$viewValue[1] = prevRangeValues.min;\n                            }\n                            // Max value should be less to equal to min value\n                            if (prevRangeValues.max <= ngModel.$viewValue[0]) {\n                                ngModel.$viewValue[0] = prevRangeValues.max;\n                            }\n                        }\n\n                        // Store values for later user\n                        prevRangeValues.min = ngModel.$viewValue[0];\n                        prevRangeValues.max = ngModel.$viewValue[1];\n\n                    }\n                    elm.slider(method, ngModel.$viewValue);\n                };\n\n                scope.$watch(attrs.ngModel, function() {\n                    if (options.range === true) {\n                        ngModel.$render();\n\n                        $(elm).find('.ui-slider-tip').each(function(i, tipElm) {\n                            $(tipElm).text(ngModel.$viewValue[i]);\n                        });\n                    } else {\n                        $(elm).find('.ui-slider-tip').text(ngModel.$viewValue);\n                    }\n                }, true);\n\n                function destroy() {\n                    if (elm.hasClass('ui-slider')) {\n                        elm.slider('destroy');\n                    }\n                }\n\n                scope.$on(\"$destroy\", destroy);\n                elm.one('$destroy', destroy);\n            };\n\n            var postLink = function (scope, element, attrs, ngModel) {\n                // Add tick marks if 'tick' and 'step' attributes have been setted on element.\n                // Support horizontal slider bar so far. 'tick' and 'step' attributes are required.\n                var options = angular.extend({}, scope.$eval(attrs.uiSlider));\n                var properties = ['min', 'max', 'step', 'tick', 'tip'];\n                angular.forEach(properties, function(property) {\n                    if (angular.isDefined(attrs[property])) {\n                        options[property] = attrs[property];\n                    }\n                });\n                if (angular.isDefined(options['tick']) && angular.isDefined(options['step'])) {\n                    var total = parseInt( (parseInt(options['max']) - parseInt(options['min'])) /parseInt(options['step']));\n                    for (var i = total; i >= 0; i--) {\n                        var left = ((i / total) * 100) + '%';\n                        $(\"<div/>\").addClass(\"ui-slider-tick\").appendTo(element).css({left: left});\n                    };\n                }\n                if(angular.isDefined(options['tip'])) {\n                    $timeout(function(){\n                        var handles = element.find('.ui-slider-handle');\n                        if(handles && handles.length>1 && ngModel.$viewValue && angular.isArray(ngModel.$viewValue)){\n                            $(handles[0]).append('<div class=\"ui-slider-tip\">'+ngModel.$viewValue[0]+'</div>');\n                            $(handles[1]).append('<div class=\"ui-slider-tip\">'+ngModel.$viewValue[1]+'</div>');\n                        }else{\n                            element.find('.ui-slider-handle').append('<div class=\"ui-slider-tip\">'+ngModel.$viewValue+'</div>');\n                        }\n                    },10);\n                }\n            }\n\n            return {\n                pre: preLink,\n                post: postLink\n            };\n        }\n    };\n}]);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/angular-ui-slider/src/slider.js\n// module id = 527\n// module chunks = 26"],"sourceRoot":""}