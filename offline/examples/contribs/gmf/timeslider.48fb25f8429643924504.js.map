{"version":3,"sources":["webpack:///./src/misc/Time.js","webpack:///./contribs/gmf/examples/timeslider.js","webpack:///./contribs/gmf/src/layertree/timeSliderComponent.js","webpack:///./src/misc/WMSTime.js"],"names":["_index","__webpack_require__","exports","prototype","getOptions","time","minDate","Date","minValue","maxDate","maxValue","minDefaultDate","minDefValue","maxDefaultDate","maxDefValue","defaultValues","mode","getTime","values","getUTCDate","localDate","getUTCFullYear","getUTCMonth","module","angular","service","ngeoBase","requires","push","name","gmfBase","gmfLayertreeTimeSliderComponent","ngeoMiscWMSTime","constant","MainController","$scope","ngeoWMSTime","this","ngeoWMSTime_","wmsTimeRangeMode","widget","resolution","interval","wmsTimeValueMode","sliderValue","sliderRangeValue","onDateSelected","date","formatWMSTimeParam","$digest","onDateRangeSelected","controller","directive_","$timeout","$filter","scope","bindToController","restrict","templateUrl","baseModuleTemplateUrl","link","pre","element","attrs","ctrl","computeDates_","e","sliderUi","sDate","eDate","wmstime","getClosestValue_","dates","start","end","value","$apply","init","sliderOptions","directive","Controller_","isModeRange","timeValueList","getTimeValueList_","initialOptions_","range","min","max","wmsTime","forEach","endDate","setFullYear","getFullYear","setMonth","getMonth","getDate","setSeconds","getSeconds","i","nextDate","timestamp","index","leftIndex","rightIndex","length","Math","floor","leftDistance","abs","rightDistance","targetDate","startDate","bestDate","bestDistance","next","distance","getLocalizedDate","formatTimeValue","olBase","gettextCatalog","$filter_","gettextCatalog_","ngeoMiscTime","call","inherits","opt_useISOFormat","opt_toUTC","utc","undefined","yearResolution","monthResolution","dayResolution","getString","toISOString","replace","wmsTimeProperty","times","googAsserts","assert"],"mappings":"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","file":"timeslider.48fb25f8429643924504.js","sourcesContent":["/**\n * @module ngeo.misc.Time\n*/\nimport ngeoBase from 'ngeo/index.js';\n\n/**\n * ngeo - Time service\n * @constructor\n * @struct\n * @ngInject\n * @ngdoc service\n * @ngname ngeoTime\n */\nconst exports = function() {};\n\n\n/**\n * Get options regarding the time property of a node;\n *\n * @param {ngeox.TimeProperty} time the time property of a node\n * @return {{\n *  minDate : number,\n *  maxDate : number,\n *  values : (Array<number>|number)\n * }} - Configuration for the UI components\n * @export\n */\nexports.prototype.getOptions = function(time) {\n\n  const minDate = new Date(time.minValue);\n  const maxDate = new Date(time.maxValue);\n\n  const minDefaultDate = (time.minDefValue) ?\n    new Date(time.minDefValue) : minDate;\n  const maxDefaultDate = (time.maxDefValue) ?\n    new Date(time.maxDefValue) : maxDate;\n\n  const defaultValues = (time.mode === 'range') ?\n    [minDefaultDate.getTime(), maxDefaultDate.getTime()] :\n    minDefaultDate.getTime();\n\n  return {\n    minDate: minDate.getTime(),\n    maxDate: maxDate.getTime(),\n    values: defaultValues\n  };\n};\n\n\n/**\n * Time.prototype.getUTCDate - Get UTC date from a local date object\n *\n * @param  {Object} localDate loacl date object in\n * @return {Object} UTC date\n * @export\n */\nexports.prototype.getUTCDate = function(localDate) {\n  return new Date(\n    localDate.getUTCFullYear(),\n    localDate.getUTCMonth(),\n    localDate.getUTCDate());\n};\n\n\n/**\n * @type {!angular.Module}\n */\nexports.module = angular.module('ngeoTime', []);\nexports.module.service('ngeoTime', exports);\nngeoBase.module.requires.push(exports.module.name);\n\n\nexport default exports;\n\n\n\n// WEBPACK FOOTER //\n// ./src/misc/Time.js","/**\n * @module gmfapp.timeslider\n*/\nconst exports = {};\n\nimport './timeslider.css';\nimport './common_dependencies.js';\nimport gmfBase from 'gmf/index.js';\n\nimport gmfLayertreeTimeSliderComponent from 'gmf/layertree/timeSliderComponent.js';\nimport ngeoMiscWMSTime from 'ngeo/misc/WMSTime.js';\n\n\n/** @type {!angular.Module} **/\nexports.module = angular.module('gmfapp', [\n  gmfBase.module.name,\n  gmfLayertreeTimeSliderComponent.name,\n  ngeoMiscWMSTime.module.name,\n]);\n\nexports.constant('angularLocaleScript', '../build/angular-locale_{{locale}}.js');\n\n\n/**\n * @constructor\n * @param {!angular.Scope} $scope Angular scope.\n * @param {!ngeo.misc.WMSTime} ngeoWMSTime wmstime service.\n * @ngInject\n */\nexports.MainController = function($scope, ngeoWMSTime) {\n\n  /**\n   * @type {ngeo.misc.WMSTime}\n   * @private\n   */\n  this.ngeoWMSTime_ = ngeoWMSTime;\n\n  /**\n   * @type {ngeox.TimeProperty}\n   * @export\n   */\n  this.wmsTimeRangeMode = {\n    widget: /** @type {ngeox.TimePropertyWidgetEnum} */ ('slider'),\n    maxValue: '2013-12-31T00:00:00Z',\n    minValue: '2006-01-01T00:00:00Z',\n    maxDefValue: null,\n    minDefValue: null,\n    resolution: /** @type {ngeox.TimePropertyResolutionEnum}*/ ('day'),\n    mode: /** @type {ngeox.TimePropertyModeEnum} */('range'),\n    interval: [0, 1, 0, 0]\n  };\n\n  /**\n   * @type {ngeox.TimeProperty}\n   * @export\n   */\n  this.wmsTimeValueMode = {\n    widget: /** @type {ngeox.TimePropertyWidgetEnum} */ ('slider'),\n    maxValue: '2015-12-31T00:00:00Z',\n    minValue: '2014-01-01T00:00:00Z',\n    maxDefValue: null,\n    minDefValue: null,\n    resolution: /** @type {ngeox.TimePropertyResolutionEnum}*/ ('year'),\n    mode: /** @type {ngeox.TimePropertyModeEnum} */ ('value'),\n    interval: [0, 0, 1, 0]\n  };\n\n  /**\n   * @type {string}\n   * @export\n   */\n  this.sliderValue;\n\n  /**\n   * @type {string}\n   * @export\n   */\n  this.sliderRangeValue;\n\n  this.onDateSelected = function(date) {\n    this.sliderValue = this.ngeoWMSTime_.formatWMSTimeParam(this.wmsTimeValueMode, date);\n    $scope.$digest();\n  };\n\n  this.onDateRangeSelected = function(date) {\n    this.sliderRangeValue = this.ngeoWMSTime_.formatWMSTimeParam(this.wmsTimeRangeMode, date);\n    $scope.$digest();\n  };\n\n};\n\n\nexports.module.controller('MainController', exports.MainController);\n\n\nexport default exports;\n\n\n\n// WEBPACK FOOTER //\n// ./contribs/gmf/examples/timeslider.js","/**\n * @module gmf.layertree.timeSliderComponent\n*/\nimport gmfBase from 'gmf/index.js';\nimport ngeoMiscWMSTime from 'ngeo/misc/WMSTime.js';\n\n/**\n * @type {!angular.Module}\n */\nconst exports = angular.module('gmfLayertreeTimeSliderComponent', [\n  ngeoMiscWMSTime.module.name,\n]);\n\ngmfBase.module.requires.push(exports.name);\n\n\n/**\n * Provide a directive to select a single date or a range of dates with a slider\n * Example:\n *\n *      <gmf-time-slider\n *          gmf-time-slider-time=\"{\n *            maxValue: '2013-12-31T00:00:00Z',\n *            minValue: '2006-01-01T00:00:00Z',\n *            mode: 'range'}\"\n *          gmf-time-slider-on-date-selected=\"ctrl.onDateSelected(time)\">\n *      </gmf-time-slider>\n *\n * @htmlAttribute {ngeox.TimeProperty} gmf-time-slider-time parameter for initialization.\n * @htmlAttribute {function()} gmf-time-slider-on-date-selected Expresion evaluated after\n * date(s) changed\n * @param {angular.$timeout} $timeout angular timeout service\n * @param {angular.$filter} $filter angular filter service\n * @return {angular.Directive} The directive specs.\n * @ngInject\n * @ngdoc directive\n * @ngname gmfTimeSlider\n */\nexports.directive_ = function($timeout, $filter) {\n  return {\n    scope: {\n      onDateSelected: '&gmfTimeSliderOnDateSelected',\n      time: '=gmfTimeSliderTime'\n    },\n    bindToController: true,\n    controller: 'gmfTimeSliderController as sliderCtrl',\n    restrict: 'AE',\n    templateUrl: `${gmfBase.baseModuleTemplateUrl}/layertree/timesliderComponent.html`,\n    link: /** @type {!angular.LinkingFunctions} */ ({\n      pre: function preLink(scope, element, attrs, ctrl) {\n        ctrl.init();\n\n        ctrl.sliderOptions['stop'] = onSliderReleased_;\n        ctrl.sliderOptions['slide'] = computeDates_;\n\n        function onSliderReleased_(e, sliderUi) {\n          ctrl.onDateSelected({\n            time: computeDates_(e, sliderUi)\n          });\n          scope.$apply();\n        }\n\n        function computeDates_(e, sliderUi) {\n          let sDate, eDate, wmstime;\n          if (sliderUi.values) {\n            sDate = new Date(ctrl.getClosestValue_(sliderUi.values[0]));\n            eDate = new Date(ctrl.getClosestValue_(sliderUi.values[1]));\n            ctrl.dates = [sDate, eDate];\n            wmstime = {\n              start: sDate.getTime(),\n              end: eDate.getTime()\n            };\n          } else {\n            sDate = new Date(ctrl.getClosestValue_(sliderUi.value));\n            ctrl.dates = sDate;\n            wmstime = {\n              start: sDate.getTime()\n            };\n          }\n          scope.$apply();\n          return wmstime;\n        }\n      }\n    })\n  };\n};\n\n\nexports.directive('gmfTimeSlider',\n  exports.directive_);\n\n\n/**\n * TimeSliderController - directive controller\n * @param {!angular.Scope} $scope Angular scope.\n * @param {ngeo.misc.WMSTime} ngeoWMSTime WMSTime service.\n * @constructor\n * @private\n * @ngInject\n * @ngdoc controller\n * @ngname gmfTimeSliderController\n */\nexports.Controller_ = function($scope, ngeoWMSTime) {\n\n  /**\n   * @type {ngeo.misc.WMSTime}\n   * @private\n   */\n  this.ngeoWMSTime_ = ngeoWMSTime;\n\n  /**\n   * Function called after date(s) changed/selected\n   * @function\n   * @export\n   */\n  this.onDateSelected;\n\n\n  /**\n   * A time object for directive initialization\n   * @type {ngeox.TimeProperty}\n   * @export\n   */\n  this.time;\n\n  /**\n   * If the component is used to select a date range\n   * @type {boolean}\n   * @export\n   */\n  this.isModeRange;\n\n  /**\n   * Minimal value of the slider (time in ms)\n   * @type {number}\n   * @export\n   */\n  this.minValue;\n\n  /**\n   * Maximal value of the slider (time in ms)\n   * @type {number}\n   * @export\n   */\n  this.maxValue;\n\n  /**\n   * Used when WMS time object has a property 'values' instead of an interval\n   * @type (?Array<number>)\n   */\n  this.timeValueList;\n\n  /**\n   * Default Slider options (used by ui-slider directive)\n   * @type {{\n   *  range : boolean,\n   *  min : number,\n   *  max : number\n   * }}\n   * @export\n   */\n  this.sliderOptions;\n\n  /**\n   * Model for the ui-slider directive (date in ms format)\n   * @type {Array.<number>|number}\n   * @export\n   */\n  this.dates;\n};\n\n\n/**\n * Initialise the controller.\n */\nexports.Controller_.prototype.init = function() {\n  this.timeValueList = this.getTimeValueList_();\n\n  // Fetch the initial options for the component\n  const initialOptions_ = this.ngeoWMSTime_.getOptions(this.time);\n  this.isModeRange = this.time.mode === 'range';\n  this.minValue = initialOptions_.minDate;\n  this.maxValue = initialOptions_.maxDate;\n  this.dates = this.isModeRange ? [initialOptions_.values[0], initialOptions_.values[1]] :\n    initialOptions_.values;\n  this.sliderOptions = {\n    range: this.isModeRange,\n    min: this.minValue,\n    max: this.maxValue\n  };\n};\n\n/**\n * TimeSliderController.prototype.getTimeValueList_ - Get a list of time value instead\n * of using the wmstime interval as a list of possibles values\n * @private\n * @return {Array<number>}  - List of timestamp representing possible values\n */\nexports.Controller_.prototype.getTimeValueList_ = function() {\n  const wmsTime = this.time;\n  let timeValueList = null;\n  const minDate = new Date(this.minValue);\n  const maxDate = new Date(this.maxValue);\n\n  if (wmsTime.values) {\n    timeValueList = [];\n    wmsTime.values.forEach((date) => {\n      timeValueList.push(new Date(date).getTime());\n    });\n  } else {\n    const maxNbValues = 1024;\n    const endDate = new Date(minDate.getTime());\n    endDate.setFullYear(minDate.getFullYear() + maxNbValues * wmsTime.interval[0]);\n    endDate.setMonth(minDate.getMonth() + maxNbValues * wmsTime.interval[1],\n      minDate.getDate() + maxNbValues * wmsTime.interval[2]);\n    endDate.setSeconds(minDate.getSeconds() + maxNbValues * wmsTime.interval[3]);\n\n    if (endDate > maxDate) {\n      // Transform interval to a list of values when the number\n      // of values is below a threshold (maxNbValues)\n      timeValueList = [];\n      for (let i = 0; ; i++) {\n        const nextDate = new Date(minDate.getTime());\n        nextDate.setFullYear(minDate.getFullYear() + i * wmsTime.interval[0]);\n        nextDate.setMonth(minDate.getMonth() + i * wmsTime.interval[1],\n          minDate.getDate() + i * wmsTime.interval[2]);\n        nextDate.setSeconds(minDate.getSeconds() + i * wmsTime.interval[3]);\n        if (nextDate <= maxDate) {\n          timeValueList.push(nextDate.getTime());\n        } else {\n          break;\n        }\n      }\n    }\n  }\n  return timeValueList;\n};\n\n\n/**\n * Compute the closest available date from the given timestamp\n * @param  {number} timestamp selected datetime (in ms format)\n * @return {number} the closest available datetime (in ms format) from the timestamp\n * @private\n */\nexports.Controller_.prototype.getClosestValue_ = function(timestamp) {\n  if (timestamp <= this.minValue) {\n    return this.minValue;\n  }\n\n  if (timestamp >= this.maxValue) {\n    return this.maxValue;\n  }\n\n  if (this.timeValueList) {\n    // Time stops are defined as a list of values\n    let index;\n    let leftIndex = 0;\n    let rightIndex = this.timeValueList.length - 1;\n\n    while ((rightIndex - leftIndex) > 1) {\n      index = Math.floor((leftIndex + rightIndex) / 2);\n      if (this.timeValueList[index] >= timestamp) {\n        rightIndex = index;\n      } else {\n        leftIndex = index;\n      }\n    }\n\n    const leftDistance = Math.abs(this.timeValueList[leftIndex] - timestamp);\n    const rightDistance = Math.abs(this.timeValueList[rightIndex] - timestamp);\n\n    return this.timeValueList[leftDistance < rightDistance ? leftIndex : rightIndex];\n  } else {\n    // Time stops are defined by a start date plus an interval\n    const targetDate = new Date(timestamp);\n    const startDate = new Date(this.minValue);\n    let bestDate = new Date(this.minValue);\n    const maxDate = new Date(this.maxValue);\n    let bestDistance = Math.abs(targetDate - bestDate);\n\n    for (let i = 1; ; i++) {\n      // The start date should always be used as a reference\n      // because adding a month twice could differ from adding\n      // two months at once\n      const next = new Date(startDate.getTime());\n      next.setFullYear(startDate.getFullYear() + i * this.time.interval[0]);\n      next.setMonth(startDate.getMonth() + i *  this.time.interval[1],\n        startDate.getDate() + i * this.time.interval[2]);\n      next.setSeconds(startDate.getSeconds() + i * this.time.interval[3]);\n\n      if (next > maxDate) {\n        break;\n      }\n\n      const distance = Math.abs(targetDate - next);\n      if (distance <= bestDistance) {\n        bestDate = next;\n        bestDistance = distance;\n      } else {\n        break;\n      }\n    }\n\n    return bestDate.getTime();\n  }\n};\n\n\n/**\n * Format and localize time regarding a resolution.\n * @param {number} time (in ms format) timestamp to format and localize.\n * @return {string} Localized date string regarding the resolution.\n * @export\n */\nexports.Controller_.prototype.getLocalizedDate = function(time) {\n  return this.ngeoWMSTime_.formatTimeValue(time, this.time.resolution);\n};\n\n\nexports.controller('gmfTimeSliderController',\n  exports.Controller_);\n\n\nexport default exports;\n\n\n\n// WEBPACK FOOTER //\n// ./contribs/gmf/src/layertree/timeSliderComponent.js","/**\n * @module ngeo.misc.WMSTime\n*/\nimport ngeoBase from 'ngeo/index.js';\nimport ngeoMiscTime from 'ngeo/misc/Time.js';\nimport googAsserts from 'goog/asserts.js';\nimport * as olBase from 'ol/index.js';\n\n/**\n * ngeo - WMS time service\n * @extends {ngeo.misc.Time}\n * @param {angular.$filter} $filter angular filter service.\n * @param {!angularGettext.Catalog} gettextCatalog service.\n * @constructor\n * @struct\n * @ngInject\n * @ngdoc service\n * @ngname ngeoWMSTime\n */\nconst exports = function($filter, gettextCatalog) {\n\n  /**\n   * @private\n   * @type {angular.$filter}\n   */\n  this.$filter_ = $filter;\n\n  /**\n   * @type {!angularGettext.Catalog}\n   * @private\n   */\n  this.gettextCatalog_ = gettextCatalog;\n\n  ngeoMiscTime.call(this);\n};\n\nolBase.inherits(exports, ngeoMiscTime);\n\n\n/**\n * Format time regarding a resolution\n * @param  {number} time (in ms format) timestamp to format\n * @param  {(ngeox.TimePropertyResolutionEnum|undefined)} resolution resolution to use\n * @param  {boolean=} opt_useISOFormat True to a ISO-8601 date string that can be used\n *     as a WMS-T Parameter. Otherwise, use a localized date format.\n * @param  {boolean=} opt_toUTC to get the UTC date\n * @return {string} Date string regarding the resolution.\n */\nexports.prototype.formatTimeValue = function(time, resolution, opt_useISOFormat, opt_toUTC) {\n  const date = new Date(time);\n  const utc = opt_toUTC ? 'UTC' : undefined;\n\n  // ISO-8601 format to use date as a WMS-T Parameter.\n  let yearResolution = 'yyyy';\n  let monthResolution = 'yyyy-MM';\n  let dayResolution = 'yyyy-MM-dd';\n\n  // Localized format.\n  if (!opt_useISOFormat) {\n    const gettextCatalog = this.gettextCatalog_;\n    yearResolution = gettextCatalog.getString('yyyy');\n    monthResolution = gettextCatalog.getString('M/yyyy');\n    dayResolution = gettextCatalog.getString('M/d/yyyy');\n  }\n\n  switch (resolution) {\n    case 'year':\n      return this.$filter_('date')(date, yearResolution, utc);\n    case 'month':\n      return this.$filter_('date')(date, monthResolution, utc);\n    case 'day':\n      return this.$filter_('date')(date, dayResolution, utc);\n    default:\n      //case \"second\":\n      return date.toISOString().replace(/\\.\\d{3}/, '');\n  }\n};\n\n\n/**\n * Format time to be used as a WMS Time query parameter\n * @param  {ngeox.TimeProperty} wmsTimeProperty a wmstime property from a node\n * @param  {{start : number, end : (number|undefined)}} times start & end time selected (in ms format)\n * @param  {boolean=} opt_toUTC to get the UTC date\n * @return {string} ISO-8601 date string ready to be used as a query parameter for a\n * WMS request\n * @export\n */\nexports.prototype.formatWMSTimeParam = function(wmsTimeProperty, times, opt_toUTC) {\n  googAsserts.assert(wmsTimeProperty.resolution !== undefined);\n  if (wmsTimeProperty.mode === 'range') {\n    googAsserts.assert(times.end !== undefined);\n    return (\n      `${this.formatTimeValue(times.start, wmsTimeProperty.resolution, true, opt_toUTC)}/${\n        this.formatTimeValue(times.end, wmsTimeProperty.resolution, true, opt_toUTC)}`\n    );\n  } else {\n    return this.formatTimeValue(times.start, wmsTimeProperty.resolution, true, opt_toUTC);\n  }\n};\n\n\n/**\n * @type {!angular.Module}\n */\nexports.module = angular.module('ngeoWMSTime', [\n  ngeoMiscTime.module.name,\n]);\nexports.module.service('ngeoWMSTime', exports);\nngeoBase.module.requires.push(exports.module.name);\n\n\nexport default exports;\n\n\n\n// WEBPACK FOOTER //\n// ./src/misc/WMSTime.js"],"sourceRoot":""}